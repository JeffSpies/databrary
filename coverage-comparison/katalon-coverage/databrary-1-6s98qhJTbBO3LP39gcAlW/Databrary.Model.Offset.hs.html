<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE GeneralizedNewtypeDeriving, DataKinds, DeriveDataTypeable #-}
<span class="lineno">    2 </span>module Databrary.Model.Offset
<span class="lineno">    3 </span>  ( Offset(..)
<span class="lineno">    4 </span>  , offsetMillis
<span class="lineno">    5 </span>  , diffTimeOffset
<span class="lineno">    6 </span>  , offsetDiffTime
<span class="lineno">    7 </span>  ) where
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>import Data.Char (isDigit, digitToInt)
<span class="lineno">   10 </span>import Data.Fixed (Fixed(..), HasResolution(..), Milli, Pico)
<span class="lineno">   11 </span>import qualified Data.Scientific as Sci
<span class="lineno">   12 </span>import qualified Data.Text as T
<span class="lineno">   13 </span>import Data.Time (DiffTime)
<span class="lineno">   14 </span>import Data.Typeable (Typeable)
<span class="lineno">   15 </span>import Database.PostgreSQL.Typed.Types (PGParameter(..), PGColumn(..))
<span class="lineno">   16 </span>import Numeric (showSigned, showFFloat, readSigned, readDec)
<span class="lineno">   17 </span>import qualified Text.ParserCombinators.ReadP as RP
<span class="lineno">   18 </span>import qualified Text.ParserCombinators.ReadPrec as RP (lift)
<span class="lineno">   19 </span>import Text.Read (readMaybe, Read(readPrec))
<span class="lineno">   20 </span>import qualified Web.Route.Invertible as R
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>import qualified Databrary.JSON as JSON
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>newtype Offset = Offset { <span class="istickedoff"><span class="decl"><span class="istickedoff">offsetMilli</span></span></span> :: Milli } deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">Real</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Fractional</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">RealFrac</span></span></span></span></span></span></span></span></span></span>, Typeable)
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>fixedToFixed :: (HasResolution a, HasResolution b) =&gt; Fixed a -&gt; Fixed b
<span class="lineno">   27 </span><span class="decl"><span class="istickedoff">fixedToFixed x@(MkFixed xv) = y where</span>
<span class="lineno">   28 </span><span class="spaces">  </span><span class="istickedoff">yv = xv * yr `div` xr</span>
<span class="lineno">   29 </span><span class="spaces">  </span><span class="istickedoff">y = MkFixed yv</span>
<span class="lineno">   30 </span><span class="spaces">  </span><span class="istickedoff">xr = resolution <span class="nottickedoff">x</span></span>
<span class="lineno">   31 </span><span class="spaces">  </span><span class="istickedoff">yr = resolution <span class="nottickedoff">y</span></span></span>
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>-- DiffTime is really Pico and has specialized realToFrac
<span class="lineno">   34 </span>diffTimeOffset :: DiffTime -&gt; Offset
<span class="lineno">   35 </span><span class="decl"><span class="istickedoff">diffTimeOffset = Offset . fixedToFixed . (realToFrac :: DiffTime -&gt; Pico)</span></span>
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>offsetDiffTime :: Offset -&gt; DiffTime
<span class="lineno">   38 </span><span class="decl"><span class="istickedoff">offsetDiffTime = (realToFrac :: Pico -&gt; DiffTime) . fixedToFixed . offsetMilli</span></span>
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>-- | Get the underlying fixed integer, before scaling to the appropriate decimal
<span class="lineno">   41 </span>offsetMillis :: Offset -&gt; Integer
<span class="lineno">   42 </span><span class="decl"><span class="istickedoff">offsetMillis (Offset (MkFixed t)) = t</span></span>
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>instance PGParameter &quot;interval&quot; Offset where
<span class="lineno">   45 </span>  <span class="decl"><span class="istickedoff">pgEncode t = pgEncode <span class="nottickedoff">t</span> . offsetDiffTime</span></span>
<span class="lineno">   46 </span>  <span class="decl"><span class="nottickedoff">pgEncodeValue e t = pgEncodeValue e t . offsetDiffTime</span></span>
<span class="lineno">   47 </span>  <span class="decl"><span class="istickedoff">pgLiteral t = pgLiteral <span class="nottickedoff">t</span> . offsetDiffTime</span></span>
<span class="lineno">   48 </span>instance PGColumn &quot;interval&quot; Offset where
<span class="lineno">   49 </span>  <span class="decl"><span class="istickedoff">pgDecode t = diffTimeOffset . pgDecode <span class="nottickedoff">t</span></span></span>
<span class="lineno">   50 </span>  <span class="decl"><span class="istickedoff">pgDecodeValue e t = diffTimeOffset . pgDecodeValue e <span class="nottickedoff">t</span></span></span>
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>-- | Display Offset using colon delimited time format
<span class="lineno">   53 </span>instance Show Offset where
<span class="lineno">   54 </span>  -- showsPrec p = showsPrec p . offsetMillis
<span class="lineno">   55 </span>  <span class="decl"><span class="istickedoff">showsPrec p (Offset t) = showSigned ss <span class="nottickedoff">p</span> t where</span>
<span class="lineno">   56 </span><span class="spaces">    </span><span class="istickedoff">ss a =</span>
<span class="lineno">   57 </span><span class="spaces">      </span><span class="istickedoff">(if h /= 0 then shows (h :: Integer) . (':' :) else id)</span>
<span class="lineno">   58 </span><span class="spaces">      </span><span class="istickedoff">. pads m' . shows m' . (':' :)</span>
<span class="lineno">   59 </span><span class="spaces">      </span><span class="istickedoff">. pads s' . showFFloat Nothing (fromIntegral s' + realToFrac f :: Double)</span>
<span class="lineno">   60 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">   61 </span><span class="spaces">      </span><span class="istickedoff">(s, f) = properFraction a</span>
<span class="lineno">   62 </span><span class="spaces">      </span><span class="istickedoff">(m, s') = divMod s 60</span>
<span class="lineno">   63 </span><span class="spaces">      </span><span class="istickedoff">(h, m') = divMod m 60</span>
<span class="lineno">   64 </span><span class="spaces">      </span><span class="istickedoff">pads x</span>
<span class="lineno">   65 </span><span class="spaces">        </span><span class="istickedoff">| x &lt; 10 = ('0' :)</span>
<span class="lineno">   66 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = id</span></span>
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>-- | Read Offset from a colon delimited time string
<span class="lineno">   69 </span>instance Read Offset where
<span class="lineno">   70 </span>  <span class="decl"><span class="istickedoff">readPrec = RP.lift $ rm RP.&lt;++ rc where</span>
<span class="lineno">   71 </span><span class="spaces">    </span><span class="istickedoff">-- parse milliseconds:</span>
<span class="lineno">   72 </span><span class="spaces">    </span><span class="istickedoff">rm = do</span>
<span class="lineno">   73 </span><span class="spaces">      </span><span class="istickedoff">m &lt;- RP.readS_to_P (readSigned readDec)</span>
<span class="lineno">   74 </span><span class="spaces">      </span><span class="istickedoff">r &lt;- RP.look</span>
<span class="lineno">   75 </span><span class="spaces">      </span><span class="istickedoff">case r of</span>
<span class="lineno">   76 </span><span class="spaces">        </span><span class="istickedoff">(':':_) -&gt; <span class="nottickedoff">RP.pfail</span></span>
<span class="lineno">   77 </span><span class="spaces">        </span><span class="istickedoff">('.':_) -&gt; <span class="nottickedoff">RP.pfail</span></span>
<span class="lineno">   78 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; return $ Offset (MkFixed m)</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="istickedoff">-- parse seconds with colons:</span>
<span class="lineno">   80 </span><span class="spaces">    </span><span class="istickedoff">rc = do</span>
<span class="lineno">   81 </span><span class="spaces">      </span><span class="istickedoff">pm &lt;- RP.option <span class="nottickedoff">'+'</span> $ RP.satisfy (`elem` &quot;-+&quot;)</span>
<span class="lineno">   82 </span><span class="spaces">      </span><span class="istickedoff">c &lt;- RP.sepBy1 (RP.readS_to_P readDec) <span class="nottickedoff">(RP.char ':')</span></span>
<span class="lineno">   83 </span><span class="spaces">      </span><span class="istickedoff">ms &lt;- <span class="nottickedoff">RP.option 0 (do</span></span>
<span class="lineno">   84 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">_ &lt;- RP.char '.'</span></span>
<span class="lineno">   85 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">foldr (\d m -&gt; 100*digitToInt d + m `div` 10) 0 &lt;$&gt; RP.many (RP.satisfy isDigit))</span></span>
<span class="lineno">   86 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Offset . MkFixed . (if pm == '-' then negate else id) . (toInteger ms +) . (1000 *) &lt;$&gt; case c of</span></span>
<span class="lineno">   87 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[s] -&gt; return s</span></span>
<span class="lineno">   88 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[m, s] -&gt; return (60*m + s)</span></span>
<span class="lineno">   89 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[h, m, s] -&gt; return (60*(60*h + m) + s)</span></span>
<span class="lineno">   90 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[d, h, m, s] -&gt; return (60*(60*(24*d + h) + m) + s)</span></span>
<span class="lineno">   91 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; RP.pfail</span></span></span>
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>-- | Format offset value for inclusion in a JSON object. Use the millisecond integer representation
<span class="lineno">   94 </span>instance JSON.ToJSON Offset where
<span class="lineno">   95 </span>  <span class="decl"><span class="istickedoff">toJSON = JSON.Number . fromInteger . offsetMillis</span></span>
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>-- | Extract from JSON value. Accept integer milliseconds, time colon formatted string, or false (0)
<span class="lineno">   98 </span>instance JSON.FromJSON Offset where
<span class="lineno">   99 </span>  <span class="decl"><span class="nottickedoff">parseJSON (JSON.Number ms) | Sci.base10Exponent ms &lt; 10 = return $ Offset $ MkFixed $ floor ms</span>
<span class="lineno">  100 </span><span class="spaces">  </span><span class="nottickedoff">parseJSON (JSON.String s) = maybe (fail &quot;Invalid offset string&quot;) return $ readMaybe $ T.unpack s</span>
<span class="lineno">  101 </span><span class="spaces">  </span><span class="nottickedoff">parseJSON (JSON.Bool False) = return 0</span>
<span class="lineno">  102 </span><span class="spaces">  </span><span class="nottickedoff">parseJSON _ = fail &quot;Invalid offset&quot;</span></span>
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>instance R.Parameter T.Text Offset where
<span class="lineno">  105 </span>  <span class="decl"><span class="nottickedoff">renderParameter = T.pack . show . offsetMillis</span></span>
<span class="lineno">  106 </span>

</pre>
</body>
</html>
