<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE OverloadedStrings, ViewPatterns #-}
<span class="lineno">    2 </span>module Databrary.Controller.Zip
<span class="lineno">    3 </span>  ( zipContainer
<span class="lineno">    4 </span>  , zipVolume
<span class="lineno">    5 </span>  , viewVolumeDescription
<span class="lineno">    6 </span>  ) where
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>import qualified Data.ByteString as BS
<span class="lineno">    9 </span>import qualified Data.ByteString.Builder as BSB
<span class="lineno">   10 </span>import qualified Data.ByteString.Char8 as BSC
<span class="lineno">   11 </span>import qualified Data.ByteString.Lazy as BSL
<span class="lineno">   12 </span>import Data.Function (on)
<span class="lineno">   13 </span>import Data.List (groupBy, partition)
<span class="lineno">   14 </span>import Data.Maybe (fromJust, maybeToList)
<span class="lineno">   15 </span>import Control.Monad.IO.Class (liftIO)
<span class="lineno">   16 </span>import Data.Monoid ((&lt;&gt;))
<span class="lineno">   17 </span>import qualified Data.RangeSet.List as RS
<span class="lineno">   18 </span>import qualified Data.Text.Encoding as TE
<span class="lineno">   19 </span>import Network.HTTP.Types (hContentType, hCacheControl, hContentLength)
<span class="lineno">   20 </span>import System.Posix.FilePath ((&lt;.&gt;))
<span class="lineno">   21 </span>import qualified Text.Blaze.Html5 as Html
<span class="lineno">   22 </span>import qualified Text.Blaze.Html.Renderer.Utf8 as Html
<span class="lineno">   23 </span>import qualified Codec.Archive.Zip as ZIP
<span class="lineno">   24 </span>import qualified System.IO as IO
<span class="lineno">   25 </span>import qualified System.Directory as DIR
<span class="lineno">   26 </span>import qualified Conduit as CND
<span class="lineno">   27 </span>import Path (parseRelFile)
<span class="lineno">   28 </span>-- import Path.IO (resolveFile')
<span class="lineno">   29 </span>
<span class="lineno">   30 </span>import Databrary.Ops
<span class="lineno">   31 </span>import Databrary.Has (view, peek, peeks)
<span class="lineno">   32 </span>import Databrary.Store.Asset
<span class="lineno">   33 </span>import Databrary.Store.Filename
<span class="lineno">   34 </span>import Databrary.Store.CSV (buildCSV)
<span class="lineno">   35 </span>import Databrary.Store.Types
<span class="lineno">   36 </span>import Databrary.Model.Id
<span class="lineno">   37 </span>import Databrary.Model.Permission
<span class="lineno">   38 </span>import Databrary.Model.Volume
<span class="lineno">   39 </span>import Databrary.Model.Container
<span class="lineno">   40 </span>import Databrary.Model.Slot
<span class="lineno">   41 </span>import Databrary.Model.RecordSlot
<span class="lineno">   42 </span>import Databrary.Model.Asset
<span class="lineno">   43 </span>import Databrary.Model.AssetSlot
<span class="lineno">   44 </span>import Databrary.Model.Format
<span class="lineno">   45 </span>import Databrary.Model.Party
<span class="lineno">   46 </span>import Databrary.Model.Citation
<span class="lineno">   47 </span>import Databrary.Model.Funding
<span class="lineno">   48 </span>import Databrary.HTTP
<span class="lineno">   49 </span>import Databrary.HTTP.Path.Parser
<span class="lineno">   50 </span>import Databrary.Action
<span class="lineno">   51 </span>import Databrary.Controller.Paths
<span class="lineno">   52 </span>import Databrary.Controller.Asset
<span class="lineno">   53 </span>import Databrary.Controller.Container
<span class="lineno">   54 </span>import Databrary.Controller.Volume
<span class="lineno">   55 </span>import Databrary.Controller.Party
<span class="lineno">   56 </span>import Databrary.Controller.CSV
<span class="lineno">   57 </span>import Databrary.Controller.Angular
<span class="lineno">   58 </span>import Databrary.Controller.IdSet
<span class="lineno">   59 </span>import Databrary.View.Zip
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>-- isOrig flags have been added to toggle the ability to access the pre-transcoded asset
<span class="lineno">   62 </span>assetZipEntry2 :: Bool -&gt; BS.ByteString -&gt; AssetSlot -&gt; Handler (ZIP.ZipArchive ())
<span class="lineno">   63 </span><span class="decl"><span class="nottickedoff">assetZipEntry2 isOrig containerDir AssetSlot{ slotAsset = a@Asset{ assetRow = ar@AssetRow{ assetId = aid}}} = do</span>
<span class="lineno">   64 </span><span class="spaces">  </span><span class="nottickedoff">origAsset &lt;- lookupOrigAsset aid</span>
<span class="lineno">   65 </span><span class="spaces">  </span><span class="nottickedoff">Just f &lt;- case isOrig of</span>
<span class="lineno">   66 </span><span class="spaces">                 </span><span class="nottickedoff">True -&gt; getAssetFile $ fromJust origAsset</span>
<span class="lineno">   67 </span><span class="spaces">                 </span><span class="nottickedoff">False -&gt; getAssetFile a</span>
<span class="lineno">   68 </span><span class="spaces">  </span><span class="nottickedoff">req &lt;- peek</span>
<span class="lineno">   69 </span><span class="spaces">  </span><span class="nottickedoff">-- (t, _) &lt;- assetCreation a</span>
<span class="lineno">   70 </span><span class="spaces">  </span><span class="nottickedoff">-- Just (t, s) &lt;- fileInfo f</span>
<span class="lineno">   71 </span><span class="spaces">  </span><span class="nottickedoff">-- liftIO (print (&quot;downloadname&quot;, assetDownloadName False True ar))</span>
<span class="lineno">   72 </span><span class="spaces">  </span><span class="nottickedoff">-- liftIO (print (&quot;format&quot;, assetFormat ar))</span>
<span class="lineno">   73 </span><span class="spaces">  </span><span class="nottickedoff">let entryName =</span>
<span class="lineno">   74 </span><span class="spaces">        </span><span class="nottickedoff">containerDir `BS.append` (case isOrig of</span>
<span class="lineno">   75 </span><span class="spaces">          </span><span class="nottickedoff">False -&gt; makeFilename (assetDownloadName True False ar) `addFormatExtension` assetFormat ar</span>
<span class="lineno">   76 </span><span class="spaces">          </span><span class="nottickedoff">True -&gt; makeFilename (assetDownloadName False True ar) `addFormatExtension` assetFormat ar)</span>
<span class="lineno">   77 </span><span class="spaces">  </span><span class="nottickedoff">entrySelector &lt;- liftIO $ (parseRelFile (BSC.unpack entryName) &gt;&gt;= ZIP.mkEntrySelector)</span>
<span class="lineno">   78 </span><span class="spaces">  </span><span class="nottickedoff">return</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="nottickedoff">(do</span>
<span class="lineno">   80 </span><span class="spaces">       </span><span class="nottickedoff">ZIP.sinkEntry ZIP.Store (CND.sourceFileBS (BSC.unpack f)) entrySelector</span>
<span class="lineno">   81 </span><span class="spaces">       </span><span class="nottickedoff">ZIP.setEntryComment (TE.decodeUtf8 $ BSL.toStrict $ BSB.toLazyByteString $ actionURL (Just req) viewAsset (HTML, assetId ar) []) entrySelector)</span></span>
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>containerZipEntry2 :: Bool -&gt; BS.ByteString -&gt; Container -&gt; [AssetSlot] -&gt; Handler (ZIP.ZipArchive ())
<span class="lineno">   84 </span><span class="decl"><span class="nottickedoff">containerZipEntry2 isOrig prefix c l = do</span>
<span class="lineno">   85 </span><span class="spaces">  </span><span class="nottickedoff">let containerDir = prefix &lt;&gt; makeFilename (containerDownloadName c) &lt;&gt; &quot;/&quot;</span>
<span class="lineno">   86 </span><span class="spaces">  </span><span class="nottickedoff">zipActs &lt;- mapM (assetZipEntry2 isOrig containerDir) l</span>
<span class="lineno">   87 </span><span class="spaces">  </span><span class="nottickedoff">return (sequence_ zipActs)</span></span>
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>volumeDescription :: Bool -&gt; Volume -&gt; (Container, [RecordSlot]) -&gt; IdSet Container -&gt; [AssetSlot] -&gt; Handler (Html.Html, [[AssetSlot]], [[AssetSlot]])
<span class="lineno">   90 </span><span class="decl"><span class="nottickedoff">volumeDescription inzip v (_, glob) cs al = do</span>
<span class="lineno">   91 </span><span class="spaces">  </span><span class="nottickedoff">cite &lt;- lookupVolumeCitation v</span>
<span class="lineno">   92 </span><span class="spaces">  </span><span class="nottickedoff">links &lt;- lookupVolumeLinks v</span>
<span class="lineno">   93 </span><span class="spaces">  </span><span class="nottickedoff">fund &lt;- lookupVolumeFunding v</span>
<span class="lineno">   94 </span><span class="spaces">  </span><span class="nottickedoff">desc &lt;- peeks $ htmlVolumeDescription inzip v (maybeToList cite ++ links) fund glob cs at ab</span>
<span class="lineno">   95 </span><span class="spaces">  </span><span class="nottickedoff">return (desc, at, ab)</span>
<span class="lineno">   96 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">   97 </span><span class="spaces">  </span><span class="nottickedoff">(at, ab) = partition (any (containerTop . containerRow . slotContainer) . assetSlot . head) $ groupBy (me `on` fmap (containerId . containerRow . slotContainer) . assetSlot) al</span>
<span class="lineno">   98 </span><span class="spaces">  </span><span class="nottickedoff">me (Just x) (Just y) = x == y</span>
<span class="lineno">   99 </span><span class="spaces">  </span><span class="nottickedoff">me _ _ = False</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>volumeZipEntry2 :: Bool -&gt; Volume -&gt; (Container, [RecordSlot]) -&gt; IdSet Container -&gt; Maybe BSB.Builder -&gt; [AssetSlot] -&gt; Handler (ZIP.ZipArchive ())
<span class="lineno">  102 </span><span class="decl"><span class="nottickedoff">volumeZipEntry2 isOrig v top cs csv al = do</span>
<span class="lineno">  103 </span><span class="spaces">  </span><span class="nottickedoff">(desc, at, ab) &lt;- volumeDescription True v top cs al -- the actual asset slot's assets arent' used any more for containers, now container zip entry does that</span>
<span class="lineno">  104 </span><span class="spaces">  </span><span class="nottickedoff">let zipDir = (makeFilename $ volumeDownloadName v ++ if idSetIsFull cs then [] else [&quot;PARTIAL&quot;]) &lt;&gt; &quot;/&quot;</span>
<span class="lineno">  105 </span><span class="spaces">  </span><span class="nottickedoff">zt &lt;- mapM (ent zipDir) at</span>
<span class="lineno">  106 </span><span class="spaces">  </span><span class="nottickedoff">zb &lt;- mapM (ent (zipDir &lt;&gt; &quot;sessions/&quot;)) ab</span>
<span class="lineno">  107 </span><span class="spaces">  </span><span class="nottickedoff">descEntrySelector &lt;- liftIO $ (parseRelFile (BSC.unpack zipDir &lt;&gt; &quot;description.html&quot;) &gt;&gt;= ZIP.mkEntrySelector)</span>
<span class="lineno">  108 </span><span class="spaces">  </span><span class="nottickedoff">spreadEntrySelector &lt;- liftIO $ (parseRelFile (BSC.unpack zipDir &lt;&gt; &quot;spreadsheet.csv&quot;) &gt;&gt;= ZIP.mkEntrySelector)</span>
<span class="lineno">  109 </span><span class="spaces">  </span><span class="nottickedoff">return</span>
<span class="lineno">  110 </span><span class="spaces">    </span><span class="nottickedoff">(do</span>
<span class="lineno">  111 </span><span class="spaces">       </span><span class="nottickedoff">sequence_ zt</span>
<span class="lineno">  112 </span><span class="spaces">       </span><span class="nottickedoff">sequence_ zb</span>
<span class="lineno">  113 </span><span class="spaces">       </span><span class="nottickedoff">ZIP.addEntry ZIP.Store (BSL.toStrict (Html.renderHtml desc)) descEntrySelector</span>
<span class="lineno">  114 </span><span class="spaces">       </span><span class="nottickedoff">maybe (pure ()) (\c -&gt; ZIP.addEntry ZIP.Store (BSL.toStrict (BSB.toLazyByteString c)) spreadEntrySelector) csv)</span>
<span class="lineno">  115 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  116 </span><span class="spaces">  </span><span class="nottickedoff">ent prefix [a@AssetSlot{ assetSlot = Nothing }] = assetZipEntry2 isOrig prefix a -- orig asset doesn't matter here as top level assets aren't transcoded, I believe</span>
<span class="lineno">  117 </span><span class="spaces">  </span><span class="nottickedoff">ent prefix (AssetSlot{ assetSlot = Just s } : _) = do</span>
<span class="lineno">  118 </span><span class="spaces">    </span><span class="nottickedoff">(acts, _) &lt;- containerZipEntryCorrectAssetSlots2 isOrig prefix (slotContainer s)</span>
<span class="lineno">  119 </span><span class="spaces">    </span><span class="nottickedoff">pure acts</span>
<span class="lineno">  120 </span><span class="spaces">  </span><span class="nottickedoff">ent _ _ = fail &quot;volumeZipEntry&quot;</span></span>
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>zipResponse2 :: BS.ByteString -&gt; ZIP.ZipArchive () -&gt; Handler Response
<span class="lineno">  123 </span><span class="decl"><span class="nottickedoff">zipResponse2 n zipAddActions = do</span>
<span class="lineno">  124 </span><span class="spaces">  </span><span class="nottickedoff">req &lt;- peek</span>
<span class="lineno">  125 </span><span class="spaces">  </span><span class="nottickedoff">u &lt;- peek</span>
<span class="lineno">  126 </span><span class="spaces">  </span><span class="nottickedoff">store &lt;- peek</span>
<span class="lineno">  127 </span><span class="spaces">  </span><span class="nottickedoff">let comment = BSL.toStrict $ BSB.toLazyByteString</span>
<span class="lineno">  128 </span><span class="spaces">        </span><span class="nottickedoff">$ BSB.string8 &quot;Downloaded by &quot; &lt;&gt; TE.encodeUtf8Builder (partyName $ partyRow u) &lt;&gt; BSB.string8 &quot; &lt;&quot; &lt;&gt; actionURL (Just req) viewParty (HTML, TargetParty $ partyId $ partyRow u) [] &lt;&gt; BSB.char8 '&gt;'</span>
<span class="lineno">  129 </span><span class="spaces">  </span><span class="nottickedoff">let temporaryZipName = (BSC.unpack . storageTemp) store &lt;&gt; &quot;placeholder.zip&quot; -- TODO: generate temporary name for extra caution?</span>
<span class="lineno">  130 </span><span class="spaces">  </span><span class="nottickedoff">h &lt;- liftIO $ IO.openFile temporaryZipName IO.ReadWriteMode</span>
<span class="lineno">  131 </span><span class="spaces">  </span><span class="nottickedoff">liftIO $ DIR.removeFile temporaryZipName</span>
<span class="lineno">  132 </span><span class="spaces">  </span><span class="nottickedoff">liftIO $ IO.hSetBinaryMode h True</span>
<span class="lineno">  133 </span><span class="spaces">  </span><span class="nottickedoff">liftIO $ ZIP.createBlindArchive h $ do</span>
<span class="lineno">  134 </span><span class="spaces">    </span><span class="nottickedoff">ZIP.setArchiveComment (TE.decodeUtf8 comment)</span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="nottickedoff">zipAddActions</span>
<span class="lineno">  136 </span><span class="spaces">  </span><span class="nottickedoff">sz &lt;- liftIO $ (IO.hSeek h IO.SeekFromEnd 0 &gt;&gt; IO.hTell h)</span>
<span class="lineno">  137 </span><span class="spaces">  </span><span class="nottickedoff">liftIO $ IO.hSeek h IO.AbsoluteSeek 0</span>
<span class="lineno">  138 </span><span class="spaces">  </span><span class="nottickedoff">return $ okResponse</span>
<span class="lineno">  139 </span><span class="spaces">    </span><span class="nottickedoff">[ (hContentType, &quot;application/zip&quot;)</span>
<span class="lineno">  140 </span><span class="spaces">    </span><span class="nottickedoff">, (&quot;content-disposition&quot;, &quot;attachment; filename=&quot; &lt;&gt; quoteHTTP (n &lt;.&gt; &quot;zip&quot;))</span>
<span class="lineno">  141 </span><span class="spaces">    </span><span class="nottickedoff">, (hCacheControl, &quot;max-age=31556926, private&quot;)</span>
<span class="lineno">  142 </span><span class="spaces">    </span><span class="nottickedoff">, (hContentLength, BSC.pack $ show $ sz)</span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="nottickedoff">] (CND.bracketP (return h) IO.hClose CND.sourceHandle :: CND.Source (CND.ResourceT IO) BS.ByteString)</span></span>
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>checkAsset :: AssetSlot -&gt; Bool
<span class="lineno">  146 </span><span class="decl"><span class="nottickedoff">checkAsset a =</span>
<span class="lineno">  147 </span><span class="spaces">  </span><span class="nottickedoff">canReadData2 getAssetSlotRelease2 getAssetSlotVolumePermission2 a &amp;&amp; assetBacked (view a)</span></span>
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>containerZipEntryCorrectAssetSlots2 :: Bool -&gt; BS.ByteString -&gt; Container -&gt; Handler (ZIP.ZipArchive (), Bool)
<span class="lineno">  150 </span><span class="decl"><span class="nottickedoff">containerZipEntryCorrectAssetSlots2 isOrig prefix c = do</span>
<span class="lineno">  151 </span><span class="spaces">  </span><span class="nottickedoff">c'&lt;- lookupContainerAssets c</span>
<span class="lineno">  152 </span><span class="spaces">  </span><span class="nottickedoff">assetSlots &lt;- case isOrig of</span>
<span class="lineno">  153 </span><span class="spaces">                     </span><span class="nottickedoff">True -&gt; do</span>
<span class="lineno">  154 </span><span class="spaces">                      </span><span class="nottickedoff">origs &lt;- lookupOrigContainerAssets c</span>
<span class="lineno">  155 </span><span class="spaces">                      </span><span class="nottickedoff">let pdfs = filterFormat c' formatNotAV</span>
<span class="lineno">  156 </span><span class="spaces">                      </span><span class="nottickedoff">return $ pdfs ++ origs</span>
<span class="lineno">  157 </span><span class="spaces">                     </span><span class="nottickedoff">False -&gt; return c'</span>
<span class="lineno">  158 </span><span class="spaces">  </span><span class="nottickedoff">let checkedAssetSlots = filter checkAsset assetSlots</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="nottickedoff">zipActs &lt;- containerZipEntry2 isOrig prefix c $ checkedAssetSlots</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="nottickedoff">pure (zipActs, null checkedAssetSlots)</span></span>
<span class="lineno">  161 </span>
<span class="lineno">  162 </span>zipContainer :: Bool -&gt; ActionRoute (Maybe (Id Volume), Id Slot)
<span class="lineno">  163 </span><span class="decl"><span class="istickedoff">zipContainer isOrig =</span>
<span class="lineno">  164 </span><span class="spaces">  </span><span class="istickedoff">let zipPath = case isOrig of</span>
<span class="lineno">  165 </span><span class="spaces">                     </span><span class="istickedoff">True -&gt; pathMaybe pathId &lt;/&gt; pathSlotId &lt;/&lt; &quot;zip&quot; &lt;/&lt; &quot;true&quot;</span>
<span class="lineno">  166 </span><span class="spaces">                     </span><span class="istickedoff">False -&gt; pathMaybe pathId &lt;/&gt; pathSlotId &lt;/&lt; &quot;zip&quot; &lt;/&lt; &quot;false&quot;</span>
<span class="lineno">  167 </span><span class="spaces">  </span><span class="istickedoff">in action <span class="nottickedoff">GET</span> zipPath $ \(vi, ci) -&gt; <span class="nottickedoff">withAuth $ do</span></span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">c &lt;- getContainer PermissionPUBLIC vi ci True</span></span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">let v = containerVolume c</span></span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">_ &lt;- maybeAction (if volumeIsPublicRestricted v then Nothing else Just ()) -- block if restricted</span></span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(zipActs, isEmpty) &lt;- containerZipEntryCorrectAssetSlots2 isOrig &quot;&quot; c</span></span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">auditSlotDownload (not $ isEmpty) (containerSlot c)</span></span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">zipResponse2 (&quot;databrary-&quot; &lt;&gt; BSC.pack (show $ volumeId $ volumeRow $ containerVolume c) &lt;&gt; &quot;-&quot; &lt;&gt; BSC.pack (show $ containerId $ containerRow c)) zipActs</span></span></span>
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>getVolumeInfo :: Id Volume -&gt; Handler (Volume, IdSet Container, [AssetSlot])
<span class="lineno">  176 </span><span class="decl"><span class="nottickedoff">getVolumeInfo vi = do</span>
<span class="lineno">  177 </span><span class="spaces">  </span><span class="nottickedoff">v &lt;- getVolume PermissionPUBLIC vi</span>
<span class="lineno">  178 </span><span class="spaces">  </span><span class="nottickedoff">_ &lt;- maybeAction (if volumeIsPublicRestricted v then Nothing else Just ()) -- block if restricted</span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="nottickedoff">s &lt;- peeks requestIdSet</span>
<span class="lineno">  180 </span><span class="spaces">  </span><span class="nottickedoff">-- let isMember = maybe (const False) (\c -&gt; RS.member (containerId $ containerRow $ slotContainer $ c))</span>
<span class="lineno">  181 </span><span class="spaces">  </span><span class="nottickedoff">-- non-exhaustive pattern found here ...v , implment in case of Nothing (Keep in mind originalAssets will not have containers, or Volumes)</span>
<span class="lineno">  182 </span><span class="spaces">  </span><span class="nottickedoff">a &lt;- filter (\a@AssetSlot{ assetSlot = Just c } -&gt; checkAsset a &amp;&amp; RS.member (containerId $ containerRow $ slotContainer $ c) s) &lt;$&gt; lookupVolumeAssetSlots v False</span>
<span class="lineno">  183 </span><span class="spaces">  </span><span class="nottickedoff">return (v, s, a)</span></span>
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>filterFormat :: [AssetSlot] -&gt; (Format -&gt; Bool)-&gt; [AssetSlot]
<span class="lineno">  186 </span><span class="decl"><span class="nottickedoff">filterFormat as f = filter (f . assetFormat . assetRow . slotAsset ) as</span></span>
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>zipVolume :: Bool -&gt; ActionRoute (Id Volume)
<span class="lineno">  189 </span><span class="decl"><span class="istickedoff">zipVolume isOrig =</span>
<span class="lineno">  190 </span><span class="spaces">  </span><span class="istickedoff">let zipPath = case isOrig of</span>
<span class="lineno">  191 </span><span class="spaces">                     </span><span class="istickedoff">True -&gt; pathId &lt;/&lt; &quot;zip&quot; &lt;/&lt; &quot;true&quot;</span>
<span class="lineno">  192 </span><span class="spaces">                     </span><span class="istickedoff">False -&gt; pathId &lt;/&lt; &quot;zip&quot; &lt;/&lt; &quot;false&quot;</span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="istickedoff">in action <span class="nottickedoff">GET</span> zipPath $ \vi -&gt; <span class="nottickedoff">withAuth $ do</span></span>
<span class="lineno">  194 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">(v, s, a) &lt;- getVolumeInfo vi</span></span>
<span class="lineno">  195 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">top:cr &lt;- lookupVolumeContainersRecords v</span></span>
<span class="lineno">  196 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">let cr' = filter ((`RS.member` s) . containerId . containerRow . fst) cr</span></span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">csv &lt;- (null cr') `unlessReturn` (volumeCSV v cr')</span></span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">zipActs &lt;- volumeZipEntry2 isOrig v top s (buildCSV &lt;$&gt; csv) a</span></span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">auditVolumeDownload (not $ null a) v</span></span>
<span class="lineno">  200 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">zipResponse2 (BSC.pack $ &quot;databrary-&quot; ++ show (volumeId $ volumeRow v) ++ if idSetIsFull s then &quot;&quot; else &quot;-partial&quot;) zipActs</span></span></span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>viewVolumeDescription :: ActionRoute (Id Volume)
<span class="lineno">  203 </span><span class="decl"><span class="istickedoff">viewVolumeDescription = action <span class="nottickedoff">GET</span> (pathId &lt;/&lt; &quot;description&quot;) $ \_ -&gt; <span class="nottickedoff">withAuth $ do</span></span>
<span class="lineno">  204 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">angular</span></span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">{-</span></span>
<span class="lineno">  206 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">(v, s, a) &lt;- getVolumeInfo vi</span></span>
<span class="lineno">  207 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">top &lt;- lookupVolumeTopContainer v</span></span>
<span class="lineno">  208 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">glob &lt;- lookupSlotRecords $ containerSlot top</span></span>
<span class="lineno">  209 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">(desc, _, _) &lt;- volumeDescription False v (top, glob) s a</span></span>
<span class="lineno">  210 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-}</span></span>
<span class="lineno">  211 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ okResponse [] (&quot;&quot;::String)</span></span></span>

</pre>
</body>
</html>
