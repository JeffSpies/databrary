// Package xo_models contains the types for schema 'public'.
package xo_models

// GENERATED BY XO. DO NOT EDIT.

import (
	"database/sql"
	"errors"

	"github.com/databrary/databrary/db/models/custom_types"
	"github.com/lib/pq"
)

// Transcode represents a row from '"public"."transcode"'.
type Transcode struct {
	Orig    int64                `json:"orig"`    // orig
	Asset   int64                `json:"asset"`   // asset
	Owner   int64                `json:"owner"`   // owner
	Segment custom_types.Segment `json:"segment"` // segment
	Options StringSlice          `json:"options"` // options
	Start   pq.NullTime          `json:"start"`   // start
	Process sql.NullInt64        `json:"process"` // process
	Log     sql.NullString       `json:"log"`     // log

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Transcode exists in the database.
func (t *Transcode) Exists() bool {
	return t._exists
}

// Deleted provides information if the Transcode has been deleted from the database.
func (t *Transcode) Deleted() bool {
	return t._deleted
}

// Insert inserts the Transcode to the database.
func (t *Transcode) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if t._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO "public"."transcode" (` +
		`"orig", "asset", "owner", "segment", "options", "start", "process", "log"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)`

	// run query
	XOLog(sqlstr, t.Orig, t.Asset, t.Owner, t.Segment, t.Options, t.Start, t.Process, t.Log)
	err = db.QueryRow(sqlstr, t.Orig, t.Asset, t.Owner, t.Segment, t.Options, t.Start, t.Process, t.Log).Scan(&t.Asset)
	if err != nil {
		return err
	}

	// set existence
	t._exists = true

	return nil
}

// Update updates the Transcode in the database.
func (t *Transcode) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !t._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if t._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."transcode" SET (` +
		`"orig", "owner", "segment", "options", "start", "process", "log"` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) WHERE "asset" = $8`

	// run query
	XOLog(sqlstr, t.Orig, t.Owner, t.Segment, t.Options, t.Start, t.Process, t.Log, t.Asset)
	_, err = db.Exec(sqlstr, t.Orig, t.Owner, t.Segment, t.Options, t.Start, t.Process, t.Log, t.Asset)
	return err
}

// Save saves the Transcode to the database.
func (t *Transcode) Save(db XODB) error {
	if t.Exists() {
		return t.Update(db)
	}

	return t.Insert(db)
}

// Upsert performs an upsert for Transcode.
//
// NOTE: PostgreSQL 9.5+ only
func (t *Transcode) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if t._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."transcode" (` +
		`"orig", "asset", "owner", "segment", "options", "start", "process", "log"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`) ON CONFLICT ("asset") DO UPDATE SET (` +
		`"orig", "asset", "owner", "segment", "options", "start", "process", "log"` +
		`) = (` +
		`EXCLUDED."orig", EXCLUDED."asset", EXCLUDED."owner", EXCLUDED."segment", EXCLUDED."options", EXCLUDED."start", EXCLUDED."process", EXCLUDED."log"` +
		`)`

	// run query
	XOLog(sqlstr, t.Orig, t.Asset, t.Owner, t.Segment, t.Options, t.Start, t.Process, t.Log)
	_, err = db.Exec(sqlstr, t.Orig, t.Asset, t.Owner, t.Segment, t.Options, t.Start, t.Process, t.Log)
	if err != nil {
		return err
	}

	// set existence
	t._exists = true

	return nil
}

// Delete deletes the Transcode from the database.
func (t *Transcode) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !t._exists {
		return nil
	}

	// if deleted, bail
	if t._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."transcode" WHERE "asset" = $1`

	// run query
	XOLog(sqlstr, t.Asset)
	_, err = db.Exec(sqlstr, t.Asset)
	if err != nil {
		return err
	}

	// set deleted
	t._deleted = true

	return nil
}

// AssetByAsset returns the Asset associated with the Transcode's Asset (asset).
//
// Generated from foreign key 'transcode_asset_fkey'.
func (t *Transcode) AssetByAsset(db XODB) (*Asset, error) {
	return AssetByID(db, t.Asset)
}

// AssetByOrig returns the Asset associated with the Transcode's Orig (orig).
//
// Generated from foreign key 'transcode_orig_fkey'.
func (t *Transcode) AssetByOrig(db XODB) (*Asset, error) {
	return AssetByID(db, t.Orig)
}

// Account returns the Account associated with the Transcode's Owner (owner).
//
// Generated from foreign key 'transcode_owner_fkey'.
func (t *Transcode) Account(db XODB) (*Account, error) {
	return AccountByID(db, t.Owner)
}

// TranscodeByAsset retrieves a row from '"public"."transcode"' as a Transcode.
//
// Generated from index 'transcode_pkey'.
func TranscodeByAsset(db XODB, asset int64) (*Transcode, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"orig", "asset", "owner", "segment", "options", "start", "process", "log" ` +
		`FROM "public"."transcode" ` +
		`WHERE "asset" = $1`

	// run query
	XOLog(sqlstr, asset)
	t := Transcode{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, asset).Scan(&t.Orig, &t.Asset, &t.Owner, &t.Segment, &t.Options, &t.Start, &t.Process, &t.Log)
	if err != nil {
		return nil, err
	}

	return &t, nil
}
