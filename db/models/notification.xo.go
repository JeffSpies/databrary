// Package xo_models contains the types for schema 'public'.
package xo_models

// GENERATED BY XO. DO NOT EDIT.

import (
	"database/sql"
	"errors"
	"time"

	"github.com/databrary/databrary/db/models/custom_types"
)

// Notification represents a row from '"public"."notification"'.
type Notification struct {
	ID         int64                `json:"id"`         // id
	Target     int64                `json:"target"`     // target
	Notice     int16                `json:"notice"`     // notice
	Time       time.Time            `json:"time"`       // time
	Delivered  NoticeDelivery       `json:"delivered"`  // delivered
	Agent      int64                `json:"agent"`      // agent
	Party      sql.NullInt64        `json:"party"`      // party
	Volume     sql.NullInt64        `json:"volume"`     // volume
	Permission Permission           `json:"permission"` // permission
	Container  sql.NullInt64        `json:"container"`  // container
	Segment    custom_types.Segment `json:"segment"`    // segment
	Asset      sql.NullInt64        `json:"asset"`      // asset
	Release    Release              `json:"release"`    // release
	Comment    sql.NullInt64        `json:"comment"`    // comment
	Tag        sql.NullInt64        `json:"tag"`        // tag

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Notification exists in the database.
func (n *Notification) Exists() bool {
	return n._exists
}

// Deleted provides information if the Notification has been deleted from the database.
func (n *Notification) Deleted() bool {
	return n._deleted
}

// Insert inserts the Notification to the database.
func (n *Notification) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if n._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO "public"."notification" (` +
		`"target", "notice", "time", "delivered", "agent", "party", "volume", "permission", "container", "segment", "asset", "release", "comment", "tag"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14` +
		`) RETURNING "id"`

	// run query
	XOLog(sqlstr, n.Target, n.Notice, n.Time, n.Delivered, n.Agent, n.Party, n.Volume, n.Permission, n.Container, n.Segment, n.Asset, n.Release, n.Comment, n.Tag)
	err = db.QueryRow(sqlstr, n.Target, n.Notice, n.Time, n.Delivered, n.Agent, n.Party, n.Volume, n.Permission, n.Container, n.Segment, n.Asset, n.Release, n.Comment, n.Tag).Scan(&n.ID)
	if err != nil {
		return err
	}

	// set existence
	n._exists = true

	return nil
}

// Update updates the Notification in the database.
func (n *Notification) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !n._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if n._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."notification" SET (` +
		`"target", "notice", "time", "delivered", "agent", "party", "volume", "permission", "container", "segment", "asset", "release", "comment", "tag"` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14` +
		`) WHERE "id" = $15`

	// run query
	XOLog(sqlstr, n.Target, n.Notice, n.Time, n.Delivered, n.Agent, n.Party, n.Volume, n.Permission, n.Container, n.Segment, n.Asset, n.Release, n.Comment, n.Tag, n.ID)
	_, err = db.Exec(sqlstr, n.Target, n.Notice, n.Time, n.Delivered, n.Agent, n.Party, n.Volume, n.Permission, n.Container, n.Segment, n.Asset, n.Release, n.Comment, n.Tag, n.ID)
	return err
}

// Save saves the Notification to the database.
func (n *Notification) Save(db XODB) error {
	if n.Exists() {
		return n.Update(db)
	}

	return n.Insert(db)
}

// Upsert performs an upsert for Notification.
//
// NOTE: PostgreSQL 9.5+ only
func (n *Notification) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if n._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."notification" (` +
		`"id", "target", "notice", "time", "delivered", "agent", "party", "volume", "permission", "container", "segment", "asset", "release", "comment", "tag"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`) ON CONFLICT ("id") DO UPDATE SET (` +
		`"id", "target", "notice", "time", "delivered", "agent", "party", "volume", "permission", "container", "segment", "asset", "release", "comment", "tag"` +
		`) = (` +
		`EXCLUDED."id", EXCLUDED."target", EXCLUDED."notice", EXCLUDED."time", EXCLUDED."delivered", EXCLUDED."agent", EXCLUDED."party", EXCLUDED."volume", EXCLUDED."permission", EXCLUDED."container", EXCLUDED."segment", EXCLUDED."asset", EXCLUDED."release", EXCLUDED."comment", EXCLUDED."tag"` +
		`)`

	// run query
	XOLog(sqlstr, n.ID, n.Target, n.Notice, n.Time, n.Delivered, n.Agent, n.Party, n.Volume, n.Permission, n.Container, n.Segment, n.Asset, n.Release, n.Comment, n.Tag)
	_, err = db.Exec(sqlstr, n.ID, n.Target, n.Notice, n.Time, n.Delivered, n.Agent, n.Party, n.Volume, n.Permission, n.Container, n.Segment, n.Asset, n.Release, n.Comment, n.Tag)
	if err != nil {
		return err
	}

	// set existence
	n._exists = true

	return nil
}

// Delete deletes the Notification from the database.
func (n *Notification) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !n._exists {
		return nil
	}

	// if deleted, bail
	if n._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."notification" WHERE "id" = $1`

	// run query
	XOLog(sqlstr, n.ID)
	_, err = db.Exec(sqlstr, n.ID)
	if err != nil {
		return err
	}

	// set deleted
	n._deleted = true

	return nil
}

// PartyByAgent returns the Party associated with the Notification's Agent (agent).
//
// Generated from foreign key 'notification_agent_fkey'.
func (n *Notification) PartyByAgent(db XODB) (*Party, error) {
	return PartyByID(db, n.Agent)
}

// Asset returns the Asset associated with the Notification's Asset (asset).
//
// Generated from foreign key 'notification_asset_fkey'.
func (n *Notification) AssetByAssetID(db XODB) (*Asset, error) {
	return AssetByID(db, n.Asset.Int64)
}

// Comment returns the Comment associated with the Notification's Comment (comment).
//
// Generated from foreign key 'notification_comment_fkey'.
func (n *Notification) CommentByCommentID(db XODB) (*Comment, error) {
	return CommentByID(db, n.Comment.Int64)
}

// Container returns the Container associated with the Notification's Container (container).
//
// Generated from foreign key 'notification_container_fkey'.
func (n *Notification) ContainerByContainerID(db XODB) (*Container, error) {
	return ContainerByID(db, n.Container.Int64)
}

// Notice returns the Notice associated with the Notification's Notice (notice).
//
// Generated from foreign key 'notification_notice_fkey'.
func (n *Notification) NoticeByNoticeID(db XODB) (*Notice, error) {
	return NoticeByID(db, n.Notice)
}

// PartyByParty returns the Party associated with the Notification's Party (party).
//
// Generated from foreign key 'notification_party_fkey'.
func (n *Notification) PartyByParty(db XODB) (*Party, error) {
	return PartyByID(db, n.Party.Int64)
}

// Tag returns the Tag associated with the Notification's Tag (tag).
//
// Generated from foreign key 'notification_tag_fkey'.
func (n *Notification) TagByTagID(db XODB) (*Tag, error) {
	return TagByID(db, n.Tag.Int64)
}

// Account returns the Account associated with the Notification's Target (target).
//
// Generated from foreign key 'notification_target_fkey'.
func (n *Notification) Account(db XODB) (*Account, error) {
	return AccountByID(db, n.Target)
}

// Volume returns the Volume associated with the Notification's Volume (volume).
//
// Generated from foreign key 'notification_volume_fkey'.
func (n *Notification) VolumeByVolumeID(db XODB) (*Volume, error) {
	return VolumeByID(db, n.Volume.Int64)
}

// NotificationsByParty retrieves a row from '"public"."notification"' as a Notification.
//
// Generated from index 'notification_party_idx'.
func NotificationsByParty(db XODB, target int64) ([]*Notification, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "target", "notice", "time", "delivered", "agent", "party", "volume", "permission", "container", "segment", "asset", "release", "comment", "tag" ` +
		`FROM "public"."notification" ` +
		`WHERE "target" = $1`

	// run query
	XOLog(sqlstr, target)
	q, err := db.Query(sqlstr, target)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Notification{}
	for q.Next() {
		n := Notification{
			_exists: true,
		}

		// scan
		err = q.Scan(&n.ID, &n.Target, &n.Notice, &n.Time, &n.Delivered, &n.Agent, &n.Party, &n.Volume, &n.Permission, &n.Container, &n.Segment, &n.Asset, &n.Release, &n.Comment, &n.Tag)
		if err != nil {
			return nil, err
		}

		res = append(res, &n)
	}

	return res, nil
}

// NotificationByID retrieves a row from '"public"."notification"' as a Notification.
//
// Generated from index 'notification_pkey'.
func NotificationByID(db XODB, id int64) (*Notification, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "target", "notice", "time", "delivered", "agent", "party", "volume", "permission", "container", "segment", "asset", "release", "comment", "tag" ` +
		`FROM "public"."notification" ` +
		`WHERE "id" = $1`

	// run query
	XOLog(sqlstr, id)
	n := Notification{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&n.ID, &n.Target, &n.Notice, &n.Time, &n.Delivered, &n.Agent, &n.Party, &n.Volume, &n.Permission, &n.Container, &n.Segment, &n.Asset, &n.Release, &n.Comment, &n.Tag)
	if err != nil {
		return nil, err
	}

	return &n, nil
}
