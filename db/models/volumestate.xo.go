// Package xo_models contains the types for schema 'public'.
package xo_models

// GENERATED BY XO. DO NOT EDIT.

import (
	"errors"
	"github.com/databrary/databrary/db/models/custom_types"
)

// VolumeState represents a row from '"public"."volume_state"'.
type VolumeState struct {
	Volume int64              `json:"volume"` // volume
	Key    string             `json:"key"`    // key
	Value  custom_types.Jsonb `json:"value"`  // value
	Public bool               `json:"public"` // public

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the VolumeState exists in the database.
func (vs *VolumeState) Exists() bool {
	return vs._exists
}

// Deleted provides information if the VolumeState has been deleted from the database.
func (vs *VolumeState) Deleted() bool {
	return vs._deleted
}

// Insert inserts the VolumeState to the database.
func (vs *VolumeState) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if vs._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO "public"."volume_state" (` +
		`"volume", "key", "value", "public"` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`)`

	// run query
	XOLog(sqlstr, vs.Volume, vs.Key, vs.Value, vs.Public)
	err = db.QueryRow(sqlstr, vs.Volume, vs.Key, vs.Value, vs.Public).Scan(&vs.Key)
	if err != nil {
		return err
	}

	// set existence
	vs._exists = true

	return nil
}

// Update updates the VolumeState in the database.
func (vs *VolumeState) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !vs._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if vs._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."volume_state" SET (` +
		`"volume", "value", "public"` +
		`) = ( ` +
		`$1, $2, $3` +
		`) WHERE "key" = $4`

	// run query
	XOLog(sqlstr, vs.Volume, vs.Value, vs.Public, vs.Key)
	_, err = db.Exec(sqlstr, vs.Volume, vs.Value, vs.Public, vs.Key)
	return err
}

// Save saves the VolumeState to the database.
func (vs *VolumeState) Save(db XODB) error {
	if vs.Exists() {
		return vs.Update(db)
	}

	return vs.Insert(db)
}

// Upsert performs an upsert for VolumeState.
//
// NOTE: PostgreSQL 9.5+ only
func (vs *VolumeState) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if vs._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."volume_state" (` +
		`"volume", "key", "value", "public"` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) ON CONFLICT ("key") DO UPDATE SET (` +
		`"volume", "key", "value", "public"` +
		`) = (` +
		`EXCLUDED."volume", EXCLUDED."key", EXCLUDED."value", EXCLUDED."public"` +
		`)`

	// run query
	XOLog(sqlstr, vs.Volume, vs.Key, vs.Value, vs.Public)
	_, err = db.Exec(sqlstr, vs.Volume, vs.Key, vs.Value, vs.Public)
	if err != nil {
		return err
	}

	// set existence
	vs._exists = true

	return nil
}

// Delete deletes the VolumeState from the database.
func (vs *VolumeState) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !vs._exists {
		return nil
	}

	// if deleted, bail
	if vs._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."volume_state" WHERE "key" = $1`

	// run query
	XOLog(sqlstr, vs.Key)
	_, err = db.Exec(sqlstr, vs.Key)
	if err != nil {
		return err
	}

	// set deleted
	vs._deleted = true

	return nil
}

// Volume returns the Volume associated with the VolumeState's Volume (volume).
//
// Generated from foreign key 'volume_state_volume_fkey'.
func (vs *VolumeState) VolumeByVolumeID(db XODB) (*Volume, error) {
	return VolumeByID(db, vs.Volume)
}

// VolumeStateByVolumeKey retrieves a row from '"public"."volume_state"' as a VolumeState.
//
// Generated from index 'volume_state_pkey'.
func VolumeStateByVolumeKey(db XODB, volume int64, key string) (*VolumeState, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"volume", "key", "value", "public" ` +
		`FROM "public"."volume_state" ` +
		`WHERE "volume" = $1 AND "key" = $2`

	// run query
	XOLog(sqlstr, volume, key)
	vs := VolumeState{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, volume, key).Scan(&vs.Volume, &vs.Key, &vs.Value, &vs.Public)
	if err != nil {
		return nil, err
	}

	return &vs, nil
}
