// Package xo_models contains the types for schema 'public'.
package xo_models

// GENERATED BY XO. DO NOT EDIT.

import (
	"errors"

	"github.com/databrary/databrary/db/models/custom_types"
)

// VolumeInclusion represents a row from '"public"."volume_inclusion"'.
type VolumeInclusion struct {
	Container int64                `json:"container"` // container
	Segment   custom_types.Segment `json:"segment"`   // segment
	Volume    int64                `json:"volume"`    // volume

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the VolumeInclusion exists in the database.
func (vi *VolumeInclusion) Exists() bool {
	return vi._exists
}

// Deleted provides information if the VolumeInclusion has been deleted from the database.
func (vi *VolumeInclusion) Deleted() bool {
	return vi._deleted
}

// Insert inserts the VolumeInclusion to the database.
func (vi *VolumeInclusion) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if vi._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO "public"."volume_inclusion" (` +
		`"container", "segment", "volume"` +
		`) VALUES (` +
		`$1, $2, $3` +
		`)`

	// run query
	XOLog(sqlstr, vi.Container, vi.Segment, vi.Volume)
	err = db.QueryRow(sqlstr, vi.Container, vi.Segment, vi.Volume).Scan(&vi.Volume)
	if err != nil {
		return err
	}

	// set existence
	vi._exists = true

	return nil
}

// Update updates the VolumeInclusion in the database.
func (vi *VolumeInclusion) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !vi._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if vi._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."volume_inclusion" SET (` +
		`"container", "segment"` +
		`) = ( ` +
		`$1, $2` +
		`) WHERE "volume" = $3`

	// run query
	XOLog(sqlstr, vi.Container, vi.Segment, vi.Volume)
	_, err = db.Exec(sqlstr, vi.Container, vi.Segment, vi.Volume)
	return err
}

// Save saves the VolumeInclusion to the database.
func (vi *VolumeInclusion) Save(db XODB) error {
	if vi.Exists() {
		return vi.Update(db)
	}

	return vi.Insert(db)
}

// Upsert performs an upsert for VolumeInclusion.
//
// NOTE: PostgreSQL 9.5+ only
func (vi *VolumeInclusion) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if vi._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."volume_inclusion" (` +
		`"container", "segment", "volume"` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) ON CONFLICT ("volume") DO UPDATE SET (` +
		`"container", "segment", "volume"` +
		`) = (` +
		`EXCLUDED."container", EXCLUDED."segment", EXCLUDED."volume"` +
		`)`

	// run query
	XOLog(sqlstr, vi.Container, vi.Segment, vi.Volume)
	_, err = db.Exec(sqlstr, vi.Container, vi.Segment, vi.Volume)
	if err != nil {
		return err
	}

	// set existence
	vi._exists = true

	return nil
}

// Delete deletes the VolumeInclusion from the database.
func (vi *VolumeInclusion) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !vi._exists {
		return nil
	}

	// if deleted, bail
	if vi._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."volume_inclusion" WHERE "volume" = $1`

	// run query
	XOLog(sqlstr, vi.Volume)
	_, err = db.Exec(sqlstr, vi.Volume)
	if err != nil {
		return err
	}

	// set deleted
	vi._deleted = true

	return nil
}

// Container returns the Container associated with the VolumeInclusion's Container (container).
//
// Generated from foreign key 'volume_inclusion_container_fkey'.
func (vi *VolumeInclusion) ContainerByContainerID(db XODB) (*Container, error) {
	return ContainerByID(db, vi.Container)
}

// Volume returns the Volume associated with the VolumeInclusion's Volume (volume).
//
// Generated from foreign key 'volume_inclusion_volume_fkey'.
func (vi *VolumeInclusion) VolumeByVolumeID(db XODB) (*Volume, error) {
	return VolumeByID(db, vi.Volume)
}

// VolumeInclusionByVolumeContainer retrieves a row from '"public"."volume_inclusion"' as a VolumeInclusion.
//
// Generated from index 'volume_inclusion_pkey'.
func VolumeInclusionByVolumeContainer(db XODB, volume int64, container int64) (*VolumeInclusion, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"container", "segment", "volume" ` +
		`FROM "public"."volume_inclusion" ` +
		`WHERE "volume" = $1 AND "container" = $2`

	// run query
	XOLog(sqlstr, volume, container)
	vi := VolumeInclusion{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, volume, container).Scan(&vi.Container, &vi.Segment, &vi.Volume)
	if err != nil {
		return nil, err
	}

	return &vi, nil
}
