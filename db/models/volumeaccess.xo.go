// Package xo_models contains the types for schema 'public'.
package xo_models

// GENERATED BY XO. DO NOT EDIT.

import (
	"database/sql"
	"errors"
)

// VolumeAccess represents a row from '"public"."volume_access"'.
type VolumeAccess struct {
	Volume     int64         `json:"volume"`     // volume
	Party      int64         `json:"party"`      // party
	Individual Permission    `json:"individual"` // individual
	Children   Permission    `json:"children"`   // children
	Sort       sql.NullInt64 `json:"sort"`       // sort

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the VolumeAccess exists in the database.
func (va *VolumeAccess) Exists() bool {
	return va._exists
}

// Deleted provides information if the VolumeAccess has been deleted from the database.
func (va *VolumeAccess) Deleted() bool {
	return va._deleted
}

// Insert inserts the VolumeAccess to the database.
func (va *VolumeAccess) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if va._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO "public"."volume_access" (` +
		`"volume", "party", "individual", "children", "sort"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)`

	// run query
	XOLog(sqlstr, va.Volume, va.Party, va.Individual, va.Children, va.Sort)
	err = db.QueryRow(sqlstr, va.Volume, va.Party, va.Individual, va.Children, va.Sort).Scan(&va.Party)
	if err != nil {
		return err
	}

	// set existence
	va._exists = true

	return nil
}

// Update updates the VolumeAccess in the database.
func (va *VolumeAccess) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !va._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if va._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."volume_access" SET (` +
		`"volume", "individual", "children", "sort"` +
		`) = ( ` +
		`$1, $2, $3, $4` +
		`) WHERE "party" = $5`

	// run query
	XOLog(sqlstr, va.Volume, va.Individual, va.Children, va.Sort, va.Party)
	_, err = db.Exec(sqlstr, va.Volume, va.Individual, va.Children, va.Sort, va.Party)
	return err
}

// Save saves the VolumeAccess to the database.
func (va *VolumeAccess) Save(db XODB) error {
	if va.Exists() {
		return va.Update(db)
	}

	return va.Insert(db)
}

// Upsert performs an upsert for VolumeAccess.
//
// NOTE: PostgreSQL 9.5+ only
func (va *VolumeAccess) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if va._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."volume_access" (` +
		`"volume", "party", "individual", "children", "sort"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) ON CONFLICT ("party") DO UPDATE SET (` +
		`"volume", "party", "individual", "children", "sort"` +
		`) = (` +
		`EXCLUDED."volume", EXCLUDED."party", EXCLUDED."individual", EXCLUDED."children", EXCLUDED."sort"` +
		`)`

	// run query
	XOLog(sqlstr, va.Volume, va.Party, va.Individual, va.Children, va.Sort)
	_, err = db.Exec(sqlstr, va.Volume, va.Party, va.Individual, va.Children, va.Sort)
	if err != nil {
		return err
	}

	// set existence
	va._exists = true

	return nil
}

// Delete deletes the VolumeAccess from the database.
func (va *VolumeAccess) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !va._exists {
		return nil
	}

	// if deleted, bail
	if va._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."volume_access" WHERE "party" = $1`

	// run query
	XOLog(sqlstr, va.Party)
	_, err = db.Exec(sqlstr, va.Party)
	if err != nil {
		return err
	}

	// set deleted
	va._deleted = true

	return nil
}

// Party returns the Party associated with the VolumeAccess's Party (party).
//
// Generated from foreign key 'volume_access_party_fkey'.
func (va *VolumeAccess) PartyByPartID(db XODB) (*Party, error) {
	return PartyByID(db, va.Party)
}

// Volume returns the Volume associated with the VolumeAccess's Volume (volume).
//
// Generated from foreign key 'volume_access_volume_fkey'.
func (va *VolumeAccess) VolumeByVolumeID(db XODB) (*Volume, error) {
	return VolumeByID(db, va.Volume)
}

// VolumeAccessByVolumeParty retrieves a row from '"public"."volume_access"' as a VolumeAccess.
//
// Generated from index 'volume_access_pkey'.
func VolumeAccessByVolumeParty(db XODB, volume int64, party int64) (*VolumeAccess, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"volume", "party", "individual", "children", "sort" ` +
		`FROM "public"."volume_access" ` +
		`WHERE "volume" = $1 AND "party" = $2`

	// run query
	XOLog(sqlstr, volume, party)
	va := VolumeAccess{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, volume, party).Scan(&va.Volume, &va.Party, &va.Individual, &va.Children, &va.Sort)
	if err != nil {
		return nil, err
	}

	return &va, nil
}
