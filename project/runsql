#!/bin/bash -e
set -o pipefail

top=`git rev-parse --show-cdup || echo "Assuming $PWD is top." >&2`
conf=${top}conf
db=default
evolutions=$conf/evolutions/$db

if [[ ! -f $conf/application.conf ]] ; then
	echo "$conf/application.conf is missing.  You are probably in the wrong directory."
	exit 1
fi

if [[ ! -f ${top}local.conf ]] ; then
	echo "${top}local.conf is missing.  See README."
	if [[ -f $conf/local.conf ]] ; then
		echo "Note: local.conf should be moved from $conf to $top."
	fi
	exit 1
fi

getconfig () {
	# This isn't perfect but hopefully good enough
	sed -n '/^'"$1"'=\("\([^"]*\)"\|\([^# ]*\)\).*$/{s//\2\3/;p;q}' ${top}local.conf $conf/application.conf
}

getdbconfig () {
	getconfig "db\.$db\.$1"
}

getdb () {
	sed -n '/^jdbc:postgresql:\(\/\/\([^\/:]\+\)\(:\([0-9]\+\)\)\?\/\)\?\([^?]*\).*$/{s//host="\2";port="\4";database="\5"/;p}'
}

eval $(getdbconfig url | getdb)
user=`getdbconfig user`
password=`getdbconfig password`
secret=`getconfig 'application\.secret'`
: ${host:=localhost} ${port:=5432} ${database:=$user}

if [[ $secret != databrary ]] ; then
	echo -n "This looks like a production environment. Continue? "
	read y
	[[ $y = y* ]] || exit 8
fi

if [[ ! -f ~/.pgpass ]] ; then
	um=`umask -p`
	umask 077
	echo "$host:$port:$database:$user:$password" >> ~/.pgpass
	$um
fi

args=(-h $host -p $port -U $user)
while [[ $1 = -?* ]] ; do
	args=("${args[@]}" $1)
	shift
done

runsql () {
	psql -q "${args[@]}" "${database}" -vON_ERROR_STOP=on -f "${@:--}"
}

dbreset () {
	if [[ -z $1 ]] ; then
		pg_dump -Fc -f unreset.dump "${args[@]}" "${database}"
	fi
	evolve down 1
}

declare -A evoexpr=([up]='0,/^# --- !Ups$/d;/^# --- !Downs$/,$d' [down]='1,/^# --- !Downs$/d')
evolve () {
	local evo=$evolutions/$2.sql
	sed -n "${evoexpr[$1]}"';/^#/d;s/;;/;/g;p' $evo | runsql
}

check_dump() {
	pg_dump -O -f $conf/check-$1.sql "${args[@]}" "${database}"
}

check_diff() {
	check_dump $2
	echo "Checking $1 vs. $2..."
	diff -F'^[A-Z]' -u0 $conf/check-$1.sql $conf/check-$2.sql
}

evolve_all () {
	n=0
	while [[ -f $evolutions/$[++n].sql ]] ; do
		if [[ -n $1 ]] ; then
			check_dump up-$n
		fi
		echo "Running evolution up $n..."
		evolve up $n
	done
}

if [[ $# -eq 0 ]] ; then
	echo "Use '$0 help' for help"
	exec psql "${args[@]}" "${database}"
elif [[ $# -eq 1 && ( $1 = - || -f $1 ) ]] ; then
	runsql "$1"
elif [[ $# -eq 1 && $1 = reset ]] ; then
	dbreset
elif [[ $# -eq 1 && $1 = schema ]] ; then
	dbreset
	runsql $conf/schema.sql
elif [[ $# -eq 1 && $1 = up ]] ; then
	dbreset
	evolve_all
elif [[ $# -eq 2 && ( $1 = up || $1 = down ) ]] ; then
	evolve "$@"
elif [[ $1 = check ]] ; then
	dbreset
	echo "Running schema..."
	runsql $conf/schema.sql
	check_dump schema
	dbreset 1
	evolve_all 1
	check_diff schema evolve
	while [[ $[--n] -ge 1 ]] ; do
		echo "Running evolution down $n..."
		evolve down $n
		check_diff up-$n down-$n
	done
	echo "All OK!"
	rm -f $conf/check-*.sql
elif [[ $1 = dump ]] ; then
	shift
	exec pg_dump "${args[@]}" "${database}" "$@"
elif [[ $1 = restore ]] ; then
	shift
	dbreset
	exec pg_restore "${args[@]}" -d "${database}" -O "$@"
else
	cat <<EOF
Usage:
  runsql  		run psql interactively
  runsql -|<file>	execute contents of file
  runsql reset		reset the database (clear public schema)
  runsql schema		apply master schema
  runsql up|down NUM	run evolution NUM (no play_evolutions)
  runsql check		apply and compare master schema and evolutions
  runsql dump ARGS...	run pg_dump
  runsql restore ARGS...	run pg_restore
Any non-argument options are passed to the run command.
EOF
fi
